// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kama.proto

#ifndef PROTOBUF_kama_2eproto__INCLUDED
#define PROTOBUF_kama_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace kama {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kama_2eproto();
void protobuf_AssignDesc_kama_2eproto();
void protobuf_ShutdownFile_kama_2eproto();

class Envelope;
class Frame;
class DataFile;
class EndSession;
class FrameContext;

// ===================================================================

class Envelope : public ::google::protobuf::Message {
 public:
  Envelope();
  virtual ~Envelope();

  Envelope(const Envelope& from);

  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Envelope& default_instance();

  void Swap(Envelope* other);

  // implements Message ----------------------------------------------

  Envelope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Envelope& from);
  void MergeFrom(const Envelope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kama.protocol.Frame frame = 1;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 1;
  inline const ::kama::protocol::Frame& frame() const;
  inline ::kama::protocol::Frame* mutable_frame();
  inline ::kama::protocol::Frame* release_frame();
  inline void set_allocated_frame(::kama::protocol::Frame* frame);

  // optional .kama.protocol.DataFile dataFile = 2;
  inline bool has_datafile() const;
  inline void clear_datafile();
  static const int kDataFileFieldNumber = 2;
  inline const ::kama::protocol::DataFile& datafile() const;
  inline ::kama::protocol::DataFile* mutable_datafile();
  inline ::kama::protocol::DataFile* release_datafile();
  inline void set_allocated_datafile(::kama::protocol::DataFile* datafile);

  // optional .kama.protocol.EndSession endSession = 3;
  inline bool has_endsession() const;
  inline void clear_endsession();
  static const int kEndSessionFieldNumber = 3;
  inline const ::kama::protocol::EndSession& endsession() const;
  inline ::kama::protocol::EndSession* mutable_endsession();
  inline ::kama::protocol::EndSession* release_endsession();
  inline void set_allocated_endsession(::kama::protocol::EndSession* endsession);

  // @@protoc_insertion_point(class_scope:kama.protocol.Envelope)
 private:
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_datafile();
  inline void clear_has_datafile();
  inline void set_has_endsession();
  inline void clear_has_endsession();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::kama::protocol::Frame* frame_;
  ::kama::protocol::DataFile* datafile_;
  ::kama::protocol::EndSession* endsession_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static Envelope* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  Frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 subscriber_number = 1;
  inline bool has_subscriber_number() const;
  inline void clear_subscriber_number();
  static const int kSubscriberNumberFieldNumber = 1;
  inline ::google::protobuf::int32 subscriber_number() const;
  inline void set_subscriber_number(::google::protobuf::int32 value);

  // required int32 measuring_pointing_number = 2;
  inline bool has_measuring_pointing_number() const;
  inline void clear_measuring_pointing_number();
  static const int kMeasuringPointingNumberFieldNumber = 2;
  inline ::google::protobuf::int32 measuring_pointing_number() const;
  inline void set_measuring_pointing_number(::google::protobuf::int32 value);

  // required int32 information_type = 3;
  inline bool has_information_type() const;
  inline void clear_information_type();
  static const int kInformationTypeFieldNumber = 3;
  inline ::google::protobuf::int32 information_type() const;
  inline void set_information_type(::google::protobuf::int32 value);

  // required int32 distance_channel_tracking_mode = 4;
  inline bool has_distance_channel_tracking_mode() const;
  inline void clear_distance_channel_tracking_mode();
  static const int kDistanceChannelTrackingModeFieldNumber = 4;
  inline ::google::protobuf::int32 distance_channel_tracking_mode() const;
  inline void set_distance_channel_tracking_mode(::google::protobuf::int32 value);

  // required int32 angle_channel_tracking_mode = 5;
  inline bool has_angle_channel_tracking_mode() const;
  inline void clear_angle_channel_tracking_mode();
  static const int kAngleChannelTrackingModeFieldNumber = 5;
  inline ::google::protobuf::int32 angle_channel_tracking_mode() const;
  inline void set_angle_channel_tracking_mode(::google::protobuf::int32 value);

  // optional int32 height_channel_tracking_mode = 6;
  inline bool has_height_channel_tracking_mode() const;
  inline void clear_height_channel_tracking_mode();
  static const int kHeightChannelTrackingModeFieldNumber = 6;
  inline ::google::protobuf::int32 height_channel_tracking_mode() const;
  inline void set_height_channel_tracking_mode(::google::protobuf::int32 value);

  // required int32 response_signal_mode = 8;
  inline bool has_response_signal_mode() const;
  inline void clear_response_signal_mode();
  static const int kResponseSignalModeFieldNumber = 8;
  inline ::google::protobuf::int32 response_signal_mode() const;
  inline void set_response_signal_mode(::google::protobuf::int32 value);

  // required int32 gain_gontrol = 9;
  inline bool has_gain_gontrol() const;
  inline void clear_gain_gontrol();
  static const int kGainGontrolFieldNumber = 9;
  inline ::google::protobuf::int32 gain_gontrol() const;
  inline void set_gain_gontrol(::google::protobuf::int32 value);

  // required int32 frequency_control = 10;
  inline bool has_frequency_control() const;
  inline void clear_frequency_control();
  static const int kFrequencyControlFieldNumber = 10;
  inline ::google::protobuf::int32 frequency_control() const;
  inline void set_frequency_control(::google::protobuf::int32 value);

  // required int32 antenna_pointing_mode = 11;
  inline bool has_antenna_pointing_mode() const;
  inline void clear_antenna_pointing_mode();
  static const int kAntennaPointingModeFieldNumber = 11;
  inline ::google::protobuf::int32 antenna_pointing_mode() const;
  inline void set_antenna_pointing_mode(::google::protobuf::int32 value);

  // required int32 distance_is_valid = 12;
  inline bool has_distance_is_valid() const;
  inline void clear_distance_is_valid();
  static const int kDistanceIsValidFieldNumber = 12;
  inline ::google::protobuf::int32 distance_is_valid() const;
  inline void set_distance_is_valid(::google::protobuf::int32 value);

  // required int32 agc_level = 13;
  inline bool has_agc_level() const;
  inline void clear_agc_level();
  static const int kAgcLevelFieldNumber = 13;
  inline ::google::protobuf::int32 agc_level() const;
  inline void set_agc_level(::google::protobuf::int32 value);

  // required int32 time_mode = 14;
  inline bool has_time_mode() const;
  inline void clear_time_mode();
  static const int kTimeModeFieldNumber = 14;
  inline ::google::protobuf::int32 time_mode() const;
  inline void set_time_mode(::google::protobuf::int32 value);

  // required string time = 15;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 15;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required double azimuth = 16;
  inline bool has_azimuth() const;
  inline void clear_azimuth();
  static const int kAzimuthFieldNumber = 16;
  inline double azimuth() const;
  inline void set_azimuth(double value);

  // required double elevation = 17;
  inline bool has_elevation() const;
  inline void clear_elevation();
  static const int kElevationFieldNumber = 17;
  inline double elevation() const;
  inline void set_elevation(double value);

  // required int32 distance = 18;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 18;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);

  // optional int32 height = 19;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 19;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional .kama.protocol.FrameContext frameConext = 20;
  inline bool has_frameconext() const;
  inline void clear_frameconext();
  static const int kFrameConextFieldNumber = 20;
  inline const ::kama::protocol::FrameContext& frameconext() const;
  inline ::kama::protocol::FrameContext* mutable_frameconext();
  inline ::kama::protocol::FrameContext* release_frameconext();
  inline void set_allocated_frameconext(::kama::protocol::FrameContext* frameconext);

  // @@protoc_insertion_point(class_scope:kama.protocol.Frame)
 private:
  inline void set_has_subscriber_number();
  inline void clear_has_subscriber_number();
  inline void set_has_measuring_pointing_number();
  inline void clear_has_measuring_pointing_number();
  inline void set_has_information_type();
  inline void clear_has_information_type();
  inline void set_has_distance_channel_tracking_mode();
  inline void clear_has_distance_channel_tracking_mode();
  inline void set_has_angle_channel_tracking_mode();
  inline void clear_has_angle_channel_tracking_mode();
  inline void set_has_height_channel_tracking_mode();
  inline void clear_has_height_channel_tracking_mode();
  inline void set_has_response_signal_mode();
  inline void clear_has_response_signal_mode();
  inline void set_has_gain_gontrol();
  inline void clear_has_gain_gontrol();
  inline void set_has_frequency_control();
  inline void clear_has_frequency_control();
  inline void set_has_antenna_pointing_mode();
  inline void clear_has_antenna_pointing_mode();
  inline void set_has_distance_is_valid();
  inline void clear_has_distance_is_valid();
  inline void set_has_agc_level();
  inline void clear_has_agc_level();
  inline void set_has_time_mode();
  inline void clear_has_time_mode();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_azimuth();
  inline void clear_has_azimuth();
  inline void set_has_elevation();
  inline void clear_has_elevation();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_frameconext();
  inline void clear_has_frameconext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 subscriber_number_;
  ::google::protobuf::int32 measuring_pointing_number_;
  ::google::protobuf::int32 information_type_;
  ::google::protobuf::int32 distance_channel_tracking_mode_;
  ::google::protobuf::int32 angle_channel_tracking_mode_;
  ::google::protobuf::int32 height_channel_tracking_mode_;
  ::google::protobuf::int32 response_signal_mode_;
  ::google::protobuf::int32 gain_gontrol_;
  ::google::protobuf::int32 frequency_control_;
  ::google::protobuf::int32 antenna_pointing_mode_;
  ::google::protobuf::int32 distance_is_valid_;
  ::google::protobuf::int32 agc_level_;
  ::std::string* time_;
  double azimuth_;
  ::google::protobuf::int32 time_mode_;
  ::google::protobuf::int32 distance_;
  double elevation_;
  ::kama::protocol::FrameContext* frameconext_;
  ::google::protobuf::int32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class DataFile : public ::google::protobuf::Message {
 public:
  DataFile();
  virtual ~DataFile();

  DataFile(const DataFile& from);

  inline DataFile& operator=(const DataFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataFile& default_instance();

  void Swap(DataFile* other);

  // implements Message ----------------------------------------------

  DataFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataFile& from);
  void MergeFrom(const DataFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mp_num = 1;
  inline bool has_mp_num() const;
  inline void clear_mp_num();
  static const int kMpNumFieldNumber = 1;
  inline ::google::protobuf::int32 mp_num() const;
  inline void set_mp_num(::google::protobuf::int32 value);

  // required string file_name = 2;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required bytes data_bytes = 3;
  inline bool has_data_bytes() const;
  inline void clear_data_bytes();
  static const int kDataBytesFieldNumber = 3;
  inline const ::std::string& data_bytes() const;
  inline void set_data_bytes(const ::std::string& value);
  inline void set_data_bytes(const char* value);
  inline void set_data_bytes(const void* value, size_t size);
  inline ::std::string* mutable_data_bytes();
  inline ::std::string* release_data_bytes();
  inline void set_allocated_data_bytes(::std::string* data_bytes);

  // optional bool main_work = 4;
  inline bool has_main_work() const;
  inline void clear_main_work();
  static const int kMainWorkFieldNumber = 4;
  inline bool main_work() const;
  inline void set_main_work(bool value);

  // @@protoc_insertion_point(class_scope:kama.protocol.DataFile)
 private:
  inline void set_has_mp_num();
  inline void clear_has_mp_num();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_data_bytes();
  inline void clear_has_data_bytes();
  inline void set_has_main_work();
  inline void clear_has_main_work();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_name_;
  ::google::protobuf::int32 mp_num_;
  bool main_work_;
  ::std::string* data_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static DataFile* default_instance_;
};
// -------------------------------------------------------------------

class EndSession : public ::google::protobuf::Message {
 public:
  EndSession();
  virtual ~EndSession();

  EndSession(const EndSession& from);

  inline EndSession& operator=(const EndSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndSession& default_instance();

  void Swap(EndSession* other);

  // implements Message ----------------------------------------------

  EndSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EndSession& from);
  void MergeFrom(const EndSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:kama.protocol.EndSession)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static EndSession* default_instance_;
};
// -------------------------------------------------------------------

class FrameContext : public ::google::protobuf::Message {
 public:
  FrameContext();
  virtual ~FrameContext();

  FrameContext(const FrameContext& from);

  inline FrameContext& operator=(const FrameContext& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrameContext& default_instance();

  void Swap(FrameContext* other);

  // implements Message ----------------------------------------------

  FrameContext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrameContext& from);
  void MergeFrom(const FrameContext& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 work_num = 1;
  inline bool has_work_num() const;
  inline void clear_work_num();
  static const int kWorkNumFieldNumber = 1;
  inline ::google::protobuf::int32 work_num() const;
  inline void set_work_num(::google::protobuf::int32 value);

  // required int32 launch_num = 2;
  inline bool has_launch_num() const;
  inline void clear_launch_num();
  static const int kLaunchNumFieldNumber = 2;
  inline ::google::protobuf::int32 launch_num() const;
  inline void set_launch_num(::google::protobuf::int32 value);

  // required bool main_work = 3;
  inline bool has_main_work() const;
  inline void clear_main_work();
  static const int kMainWorkFieldNumber = 3;
  inline bool main_work() const;
  inline void set_main_work(bool value);

  // @@protoc_insertion_point(class_scope:kama.protocol.FrameContext)
 private:
  inline void set_has_work_num();
  inline void clear_has_work_num();
  inline void set_has_launch_num();
  inline void clear_has_launch_num();
  inline void set_has_main_work();
  inline void clear_has_main_work();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 work_num_;
  ::google::protobuf::int32 launch_num_;
  bool main_work_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kama_2eproto();
  friend void protobuf_AssignDesc_kama_2eproto();
  friend void protobuf_ShutdownFile_kama_2eproto();

  void InitAsDefaultInstance();
  static FrameContext* default_instance_;
};
// ===================================================================


// ===================================================================

// Envelope

// optional .kama.protocol.Frame frame = 1;
inline bool Envelope::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Envelope::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Envelope::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Envelope::clear_frame() {
  if (frame_ != NULL) frame_->::kama::protocol::Frame::Clear();
  clear_has_frame();
}
inline const ::kama::protocol::Frame& Envelope::frame() const {
  return frame_ != NULL ? *frame_ : *default_instance_->frame_;
}
inline ::kama::protocol::Frame* Envelope::mutable_frame() {
  set_has_frame();
  if (frame_ == NULL) frame_ = new ::kama::protocol::Frame;
  return frame_;
}
inline ::kama::protocol::Frame* Envelope::release_frame() {
  clear_has_frame();
  ::kama::protocol::Frame* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_frame(::kama::protocol::Frame* frame) {
  delete frame_;
  frame_ = frame;
  if (frame) {
    set_has_frame();
  } else {
    clear_has_frame();
  }
}

// optional .kama.protocol.DataFile dataFile = 2;
inline bool Envelope::has_datafile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Envelope::set_has_datafile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Envelope::clear_has_datafile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Envelope::clear_datafile() {
  if (datafile_ != NULL) datafile_->::kama::protocol::DataFile::Clear();
  clear_has_datafile();
}
inline const ::kama::protocol::DataFile& Envelope::datafile() const {
  return datafile_ != NULL ? *datafile_ : *default_instance_->datafile_;
}
inline ::kama::protocol::DataFile* Envelope::mutable_datafile() {
  set_has_datafile();
  if (datafile_ == NULL) datafile_ = new ::kama::protocol::DataFile;
  return datafile_;
}
inline ::kama::protocol::DataFile* Envelope::release_datafile() {
  clear_has_datafile();
  ::kama::protocol::DataFile* temp = datafile_;
  datafile_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_datafile(::kama::protocol::DataFile* datafile) {
  delete datafile_;
  datafile_ = datafile;
  if (datafile) {
    set_has_datafile();
  } else {
    clear_has_datafile();
  }
}

// optional .kama.protocol.EndSession endSession = 3;
inline bool Envelope::has_endsession() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Envelope::set_has_endsession() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Envelope::clear_has_endsession() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Envelope::clear_endsession() {
  if (endsession_ != NULL) endsession_->::kama::protocol::EndSession::Clear();
  clear_has_endsession();
}
inline const ::kama::protocol::EndSession& Envelope::endsession() const {
  return endsession_ != NULL ? *endsession_ : *default_instance_->endsession_;
}
inline ::kama::protocol::EndSession* Envelope::mutable_endsession() {
  set_has_endsession();
  if (endsession_ == NULL) endsession_ = new ::kama::protocol::EndSession;
  return endsession_;
}
inline ::kama::protocol::EndSession* Envelope::release_endsession() {
  clear_has_endsession();
  ::kama::protocol::EndSession* temp = endsession_;
  endsession_ = NULL;
  return temp;
}
inline void Envelope::set_allocated_endsession(::kama::protocol::EndSession* endsession) {
  delete endsession_;
  endsession_ = endsession;
  if (endsession) {
    set_has_endsession();
  } else {
    clear_has_endsession();
  }
}

// -------------------------------------------------------------------

// Frame

// optional int32 subscriber_number = 1;
inline bool Frame::has_subscriber_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_subscriber_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_subscriber_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_subscriber_number() {
  subscriber_number_ = 0;
  clear_has_subscriber_number();
}
inline ::google::protobuf::int32 Frame::subscriber_number() const {
  return subscriber_number_;
}
inline void Frame::set_subscriber_number(::google::protobuf::int32 value) {
  set_has_subscriber_number();
  subscriber_number_ = value;
}

// required int32 measuring_pointing_number = 2;
inline bool Frame::has_measuring_pointing_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_measuring_pointing_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_measuring_pointing_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_measuring_pointing_number() {
  measuring_pointing_number_ = 0;
  clear_has_measuring_pointing_number();
}
inline ::google::protobuf::int32 Frame::measuring_pointing_number() const {
  return measuring_pointing_number_;
}
inline void Frame::set_measuring_pointing_number(::google::protobuf::int32 value) {
  set_has_measuring_pointing_number();
  measuring_pointing_number_ = value;
}

// required int32 information_type = 3;
inline bool Frame::has_information_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_information_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_information_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_information_type() {
  information_type_ = 0;
  clear_has_information_type();
}
inline ::google::protobuf::int32 Frame::information_type() const {
  return information_type_;
}
inline void Frame::set_information_type(::google::protobuf::int32 value) {
  set_has_information_type();
  information_type_ = value;
}

// required int32 distance_channel_tracking_mode = 4;
inline bool Frame::has_distance_channel_tracking_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame::set_has_distance_channel_tracking_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Frame::clear_has_distance_channel_tracking_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Frame::clear_distance_channel_tracking_mode() {
  distance_channel_tracking_mode_ = 0;
  clear_has_distance_channel_tracking_mode();
}
inline ::google::protobuf::int32 Frame::distance_channel_tracking_mode() const {
  return distance_channel_tracking_mode_;
}
inline void Frame::set_distance_channel_tracking_mode(::google::protobuf::int32 value) {
  set_has_distance_channel_tracking_mode();
  distance_channel_tracking_mode_ = value;
}

// required int32 angle_channel_tracking_mode = 5;
inline bool Frame::has_angle_channel_tracking_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Frame::set_has_angle_channel_tracking_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Frame::clear_has_angle_channel_tracking_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Frame::clear_angle_channel_tracking_mode() {
  angle_channel_tracking_mode_ = 0;
  clear_has_angle_channel_tracking_mode();
}
inline ::google::protobuf::int32 Frame::angle_channel_tracking_mode() const {
  return angle_channel_tracking_mode_;
}
inline void Frame::set_angle_channel_tracking_mode(::google::protobuf::int32 value) {
  set_has_angle_channel_tracking_mode();
  angle_channel_tracking_mode_ = value;
}

// optional int32 height_channel_tracking_mode = 6;
inline bool Frame::has_height_channel_tracking_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Frame::set_has_height_channel_tracking_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Frame::clear_has_height_channel_tracking_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Frame::clear_height_channel_tracking_mode() {
  height_channel_tracking_mode_ = 0;
  clear_has_height_channel_tracking_mode();
}
inline ::google::protobuf::int32 Frame::height_channel_tracking_mode() const {
  return height_channel_tracking_mode_;
}
inline void Frame::set_height_channel_tracking_mode(::google::protobuf::int32 value) {
  set_has_height_channel_tracking_mode();
  height_channel_tracking_mode_ = value;
}

// required int32 response_signal_mode = 8;
inline bool Frame::has_response_signal_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Frame::set_has_response_signal_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Frame::clear_has_response_signal_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Frame::clear_response_signal_mode() {
  response_signal_mode_ = 0;
  clear_has_response_signal_mode();
}
inline ::google::protobuf::int32 Frame::response_signal_mode() const {
  return response_signal_mode_;
}
inline void Frame::set_response_signal_mode(::google::protobuf::int32 value) {
  set_has_response_signal_mode();
  response_signal_mode_ = value;
}

// required int32 gain_gontrol = 9;
inline bool Frame::has_gain_gontrol() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Frame::set_has_gain_gontrol() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Frame::clear_has_gain_gontrol() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Frame::clear_gain_gontrol() {
  gain_gontrol_ = 0;
  clear_has_gain_gontrol();
}
inline ::google::protobuf::int32 Frame::gain_gontrol() const {
  return gain_gontrol_;
}
inline void Frame::set_gain_gontrol(::google::protobuf::int32 value) {
  set_has_gain_gontrol();
  gain_gontrol_ = value;
}

// required int32 frequency_control = 10;
inline bool Frame::has_frequency_control() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Frame::set_has_frequency_control() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Frame::clear_has_frequency_control() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Frame::clear_frequency_control() {
  frequency_control_ = 0;
  clear_has_frequency_control();
}
inline ::google::protobuf::int32 Frame::frequency_control() const {
  return frequency_control_;
}
inline void Frame::set_frequency_control(::google::protobuf::int32 value) {
  set_has_frequency_control();
  frequency_control_ = value;
}

// required int32 antenna_pointing_mode = 11;
inline bool Frame::has_antenna_pointing_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Frame::set_has_antenna_pointing_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Frame::clear_has_antenna_pointing_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Frame::clear_antenna_pointing_mode() {
  antenna_pointing_mode_ = 0;
  clear_has_antenna_pointing_mode();
}
inline ::google::protobuf::int32 Frame::antenna_pointing_mode() const {
  return antenna_pointing_mode_;
}
inline void Frame::set_antenna_pointing_mode(::google::protobuf::int32 value) {
  set_has_antenna_pointing_mode();
  antenna_pointing_mode_ = value;
}

// required int32 distance_is_valid = 12;
inline bool Frame::has_distance_is_valid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Frame::set_has_distance_is_valid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Frame::clear_has_distance_is_valid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Frame::clear_distance_is_valid() {
  distance_is_valid_ = 0;
  clear_has_distance_is_valid();
}
inline ::google::protobuf::int32 Frame::distance_is_valid() const {
  return distance_is_valid_;
}
inline void Frame::set_distance_is_valid(::google::protobuf::int32 value) {
  set_has_distance_is_valid();
  distance_is_valid_ = value;
}

// required int32 agc_level = 13;
inline bool Frame::has_agc_level() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Frame::set_has_agc_level() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Frame::clear_has_agc_level() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Frame::clear_agc_level() {
  agc_level_ = 0;
  clear_has_agc_level();
}
inline ::google::protobuf::int32 Frame::agc_level() const {
  return agc_level_;
}
inline void Frame::set_agc_level(::google::protobuf::int32 value) {
  set_has_agc_level();
  agc_level_ = value;
}

// required int32 time_mode = 14;
inline bool Frame::has_time_mode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Frame::set_has_time_mode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Frame::clear_has_time_mode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Frame::clear_time_mode() {
  time_mode_ = 0;
  clear_has_time_mode();
}
inline ::google::protobuf::int32 Frame::time_mode() const {
  return time_mode_;
}
inline void Frame::set_time_mode(::google::protobuf::int32 value) {
  set_has_time_mode();
  time_mode_ = value;
}

// required string time = 15;
inline bool Frame::has_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Frame::set_has_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Frame::clear_has_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Frame::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Frame::time() const {
  return *time_;
}
inline void Frame::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Frame::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void Frame::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* Frame::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Frame::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double azimuth = 16;
inline bool Frame::has_azimuth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Frame::set_has_azimuth() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Frame::clear_has_azimuth() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Frame::clear_azimuth() {
  azimuth_ = 0;
  clear_has_azimuth();
}
inline double Frame::azimuth() const {
  return azimuth_;
}
inline void Frame::set_azimuth(double value) {
  set_has_azimuth();
  azimuth_ = value;
}

// required double elevation = 17;
inline bool Frame::has_elevation() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Frame::set_has_elevation() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Frame::clear_has_elevation() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Frame::clear_elevation() {
  elevation_ = 0;
  clear_has_elevation();
}
inline double Frame::elevation() const {
  return elevation_;
}
inline void Frame::set_elevation(double value) {
  set_has_elevation();
  elevation_ = value;
}

// required int32 distance = 18;
inline bool Frame::has_distance() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Frame::set_has_distance() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Frame::clear_has_distance() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Frame::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 Frame::distance() const {
  return distance_;
}
inline void Frame::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// optional int32 height = 19;
inline bool Frame::has_height() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Frame::set_has_height() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Frame::clear_has_height() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Frame::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Frame::height() const {
  return height_;
}
inline void Frame::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional .kama.protocol.FrameContext frameConext = 20;
inline bool Frame::has_frameconext() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Frame::set_has_frameconext() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Frame::clear_has_frameconext() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Frame::clear_frameconext() {
  if (frameconext_ != NULL) frameconext_->::kama::protocol::FrameContext::Clear();
  clear_has_frameconext();
}
inline const ::kama::protocol::FrameContext& Frame::frameconext() const {
  return frameconext_ != NULL ? *frameconext_ : *default_instance_->frameconext_;
}
inline ::kama::protocol::FrameContext* Frame::mutable_frameconext() {
  set_has_frameconext();
  if (frameconext_ == NULL) frameconext_ = new ::kama::protocol::FrameContext;
  return frameconext_;
}
inline ::kama::protocol::FrameContext* Frame::release_frameconext() {
  clear_has_frameconext();
  ::kama::protocol::FrameContext* temp = frameconext_;
  frameconext_ = NULL;
  return temp;
}
inline void Frame::set_allocated_frameconext(::kama::protocol::FrameContext* frameconext) {
  delete frameconext_;
  frameconext_ = frameconext;
  if (frameconext) {
    set_has_frameconext();
  } else {
    clear_has_frameconext();
  }
}

// -------------------------------------------------------------------

// DataFile

// required int32 mp_num = 1;
inline bool DataFile::has_mp_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataFile::set_has_mp_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataFile::clear_has_mp_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataFile::clear_mp_num() {
  mp_num_ = 0;
  clear_has_mp_num();
}
inline ::google::protobuf::int32 DataFile::mp_num() const {
  return mp_num_;
}
inline void DataFile::set_mp_num(::google::protobuf::int32 value) {
  set_has_mp_num();
  mp_num_ = value;
}

// required string file_name = 2;
inline bool DataFile::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataFile::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataFile::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataFile::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& DataFile::file_name() const {
  return *file_name_;
}
inline void DataFile::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void DataFile::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void DataFile::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataFile::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* DataFile::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataFile::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data_bytes = 3;
inline bool DataFile::has_data_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataFile::set_has_data_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataFile::clear_has_data_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataFile::clear_data_bytes() {
  if (data_bytes_ != &::google::protobuf::internal::kEmptyString) {
    data_bytes_->clear();
  }
  clear_has_data_bytes();
}
inline const ::std::string& DataFile::data_bytes() const {
  return *data_bytes_;
}
inline void DataFile::set_data_bytes(const ::std::string& value) {
  set_has_data_bytes();
  if (data_bytes_ == &::google::protobuf::internal::kEmptyString) {
    data_bytes_ = new ::std::string;
  }
  data_bytes_->assign(value);
}
inline void DataFile::set_data_bytes(const char* value) {
  set_has_data_bytes();
  if (data_bytes_ == &::google::protobuf::internal::kEmptyString) {
    data_bytes_ = new ::std::string;
  }
  data_bytes_->assign(value);
}
inline void DataFile::set_data_bytes(const void* value, size_t size) {
  set_has_data_bytes();
  if (data_bytes_ == &::google::protobuf::internal::kEmptyString) {
    data_bytes_ = new ::std::string;
  }
  data_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataFile::mutable_data_bytes() {
  set_has_data_bytes();
  if (data_bytes_ == &::google::protobuf::internal::kEmptyString) {
    data_bytes_ = new ::std::string;
  }
  return data_bytes_;
}
inline ::std::string* DataFile::release_data_bytes() {
  clear_has_data_bytes();
  if (data_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_bytes_;
    data_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DataFile::set_allocated_data_bytes(::std::string* data_bytes) {
  if (data_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete data_bytes_;
  }
  if (data_bytes) {
    set_has_data_bytes();
    data_bytes_ = data_bytes;
  } else {
    clear_has_data_bytes();
    data_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool main_work = 4;
inline bool DataFile::has_main_work() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataFile::set_has_main_work() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataFile::clear_has_main_work() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataFile::clear_main_work() {
  main_work_ = false;
  clear_has_main_work();
}
inline bool DataFile::main_work() const {
  return main_work_;
}
inline void DataFile::set_main_work(bool value) {
  set_has_main_work();
  main_work_ = value;
}

// -------------------------------------------------------------------

// EndSession

// -------------------------------------------------------------------

// FrameContext

// required int32 work_num = 1;
inline bool FrameContext::has_work_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameContext::set_has_work_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameContext::clear_has_work_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameContext::clear_work_num() {
  work_num_ = 0;
  clear_has_work_num();
}
inline ::google::protobuf::int32 FrameContext::work_num() const {
  return work_num_;
}
inline void FrameContext::set_work_num(::google::protobuf::int32 value) {
  set_has_work_num();
  work_num_ = value;
}

// required int32 launch_num = 2;
inline bool FrameContext::has_launch_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrameContext::set_has_launch_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrameContext::clear_has_launch_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrameContext::clear_launch_num() {
  launch_num_ = 0;
  clear_has_launch_num();
}
inline ::google::protobuf::int32 FrameContext::launch_num() const {
  return launch_num_;
}
inline void FrameContext::set_launch_num(::google::protobuf::int32 value) {
  set_has_launch_num();
  launch_num_ = value;
}

// required bool main_work = 3;
inline bool FrameContext::has_main_work() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrameContext::set_has_main_work() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrameContext::clear_has_main_work() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrameContext::clear_main_work() {
  main_work_ = false;
  clear_has_main_work();
}
inline bool FrameContext::main_work() const {
  return main_work_;
}
inline void FrameContext::set_main_work(bool value) {
  set_has_main_work();
  main_work_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace kama

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kama_2eproto__INCLUDED
